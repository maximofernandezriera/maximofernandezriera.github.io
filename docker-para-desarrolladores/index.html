<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />

    <title>reveal-md</title>
    <link rel="shortcut icon" href="./favicon.ico" />
    <link rel="stylesheet" href="./dist/reset.css" />
    <link rel="stylesheet" href="./dist/reveal.css" />
    <link rel="stylesheet" href="./dist/theme/white.css" id="theme" />
    <link rel="stylesheet" href="./css/highlight/base16/zenburn.css" />


  </head>
  <body>
    <div class="reveal">
      <div class="slides"><section  data-markdown><script type="text/template"># Docker para desarrolladores
</script></section><section  data-markdown><script type="text/template">
# Os admiro :)
</script></section><section  data-markdown><script type="text/template">
# Así que para mí es todo un reto pero me encanta
</script></section><section  data-markdown><script type="text/template">
# Sobre mí

- https://maximofernandez.com/
- https://github.com/maximofernandezriera
- https://linktr.ee/MaximoFernandez
</script></section><section  data-markdown><script type="text/template">

# Recursos del curso

- Diapositivas: https://maximofernandez.com/docker-para-desarrolladores
- PWD: https://labs.play-with-docker.com/
- GCS: https://console.cloud.google.com/
</script></section><section  data-markdown><script type="text/template">
# Para esta sesión

- Un cuenta de Docker Hub.
- Una cuenta de github.
- https://github.com/maximofernandezriera/curso-docker
- [SSH KEY PAIR](https://docs.oracle.com/en/cloud/cloud-at-customer/occ-get-started/generate-ssh-key-pair.html)
</script></section><section  data-markdown><script type="text/template">
## Sesión 1
</script></section><section  data-markdown><script type="text/template">
# En cuanto al SSH y PWD

https://github.com/play-with-docker/play-with-docker/issues/529

[Mi SSH](https://gist.githubusercontent.com/maximofernandezriera/67e8f0ab59617dd826d5b360da88ee94/raw/b5800c8568751d1724eaeeb6f12d79b16fb8e905/playwithdocker)
</script></section><section  data-markdown><script type="text/template">
# He utilizado Docker

- Sistemas informáticos
- Entornos de desarrollo
- Base de datos
- Programación (DUAL Intensiva)
- Sistemas de gestión empresarial
- Puesta en producción segura
</script></section><section  data-markdown><script type="text/template">
# Utilizaré Docker

- Acceso a datos
- Despliegue de aplicaciones web
- Implantación de aplicaciones web
- Seguridad y alta disponibilidad
- Administración de Sistemas Operativos
- Y más ...
</script></section><section ><section data-markdown><script type="text/template">
# ¿Qué es Docker?

- **Docker** es una plataforma que facilita el desarrollo, despliegue y ejecución de aplicaciones.
- Permite **separar las aplicaciones de la infraestructura**, incrementando la eficiencia y comodidad en el trabajo.
- Docker permite **empaquetar y ejecutar aplicaciones en un entorno aislado**, llamado contenedor.
</script></section><section data-markdown><script type="text/template">
# ¿Qué es Docker?

- Los contenedores se ejecutan **directamente sobre el kernel de la máquina**, lo que los hace más ligeros que las máquinas virtuales.
- Esto permite **ejecutar un mayor número de contenedores en el mismo equipo**.
- Facilita la **realización de pruebas rápidas** de la aplicación en múltiples entornos.
</script></section><section data-markdown><script type="text/template">
# ¿Qué es Docker?

- Comparado con las máquinas virtuales, Docker **reduce el tiempo de carga y el espacio requerido**.
- El resultado es un **desarrollo más rápido y cómodo**.
- https://www.docker.com/
</script></section></section><section ><section data-markdown><script type="text/template">
# Una comparación adecuada

- Los contenedores son un símil de la problemática existentes en la gestión de mercancías en el pasado.
- Cada transportista manejaba sus propios tipos de contendores o embalajes (cajas, cestas, bolsas), lo que suponía un grave problema de logística.
- Se decidió adaptar un formato estándar de contenedor para evitar estos problemas.
</script></section><section data-markdown><script type="text/template">
# Una comparación adecuada

- Este tipo de estandarización en el modo de trabajar suspuso un enorme ahorro de coste y energía.
- Este tipo de estandarización en el lugar de trabajo (entorno de trabajo) suspuso un enorme ahorro de coste y energía.
</script></section><section data-markdown><script type="text/template">
![Captura de pantalla de 2023-05-20 10-59-46](https://github.com/maximofernandezriera/curso-docker/assets/43608040/4b052b43-ecc4-40d8-a49f-10a3fd911831)
</script></section></section><section ><section data-markdown><script type="text/template">
# Contenedores

- Los **contenedores** se diferencian de las máquinas virtuales en que no emulan un ordenador físico ni instalan un sistema operativo completo.
- En cambio, los contenedores utilizan el **kernel del sistema operativo anfitrión** pero contienen las capas superiores (sistema de ficheros, utilidades, aplicaciones).
</script></section><section data-markdown><script type="text/template">
# Contenedores

- Al evitar la emulación del hardware y el sistema operativo completo, los contenedores son **más pequeños y rápidos** que las máquinas virtuales.
- A pesar de ello, al incluir el resto de capas de software, los contenedores logran el **aislamiento e independencia** entre ellos, una característica deseable que se busca con las máquinas virtuales.
</script></section><section data-markdown><script type="text/template">
![Captura de pantalla de 2023-05-20 11-10-01](https://github.com/maximofernandezriera/curso-docker/assets/43608040/396ba7b8-c28d-4cf1-a586-43e55c36f0ce)
</script></section><section data-markdown><script type="text/template">
# Contenedores

- **Docker** no es una plataforma de virtualización, por lo que no incluye un hipervisor. Los procesos dentro de un contenedor Docker se ejecutan en el mismo kernel que la máquina anfitrión.
- Docker es capaz de aislar los procesos del contenedor del resto del sistema, ya sean procesos de la máquina anfitrión o de otros contenedores.
</script></section><section data-markdown><script type="text/template">
# Contenedores

- Podemos **controlar los recursos** asignados a los contenedores, como la CPU y la memoria.
- Internamente, un contenedor no tiene consciencia de que lo es, y funciona como una distribución **GNU/Linux independiente**, sin la penalización de rendimiento de los sistemas virtualizados.
</script></section><section data-markdown><script type="text/template">
# Contenedores

- Al ejecutar un contenedor, estás ejecutando un servicio en una distribución construida a partir de una "receta", lo que garantiza la consistencia del sistema, independientemente del sistema operativo base (Ubuntu, Fedora, etc.).
- Esto asegura el desarrollo o despliegue de una aplicación con la **misma versión de todas las dependencias**, sin importar el entorno.
</script></section><section data-markdown><script type="text/template">
![Captura de pantalla de 2023-05-13 16-41-28](https://github.com/maximofernandezriera/curso-docker/assets/43608040/1eaf155f-bd7b-4c42-af96-3ff3f6ed51f0)
</script></section><section data-markdown><script type="text/template">
# Contenedores

- Algo importante: los contenedores están pensados como objetos de "usar y tirar", es decir, para ser creados, destruidos y creados de nuevo tantas veces como sea necesario y en la cantidad que sea necesaria.
</script></section><section data-markdown><script type="text/template">
![Captura de pantalla de 2023-05-20 11-15-09](https://github.com/maximofernandezriera/curso-docker/assets/43608040/4cf84611-9afe-463e-a7e2-564eff17f50b)
</script></section></section><section ><section data-markdown><script type="text/template">
# Imágenes

- Una **Imagen** es una plantilla de solo lectura que contiene las instrucciones para crear un contenedor Docker.
- Las imágenes pueden estar **basadas en otras imágenes**, usando ficheros para definirlas.
- Un ejemplo de imagen podría ser un sistema operativo **Ubuntu con un servidor Apache** y nuestra aplicación web instalada.
</script></section><section data-markdown><script type="text/template">
![Captura de pantalla de 2023-05-13 14-17-13](https://github.com/maximofernandezriera/curso-docker/assets/43608040/1d0d89f5-d7ad-493b-8a0a-1357c4f8e858)
</script></section></section><section ><section data-markdown><script type="text/template">
# Imágenes y contenedores

- Un **contenedor** es una instancia ejecutable de una imagen.
- Esta instancia puede ser **creada, iniciada, detenida, movida o eliminada** a través del cliente de Docker o de la API.
</script></section><section data-markdown><script type="text/template">
# Imágenes y contenedores

- Se puede controlar el nivel de **aislamiento del contenedor** del sistema anfitrión y del resto de contenedores.
- El contenedor está definido tanto por la imagen de la que procede como de las opciones de configuración que permita.
</script></section><section data-markdown><script type="text/template">
# Imágenes y contenedores

- Las instancias de contenedores pueden ser conectadas a una o más redes, sistemas de almacenamiento, o incluso se puede crear una imagen a partir del estado de un contenedor.
</script></section><section data-markdown><script type="text/template">
# Imágenes y contenedores

- Por ejemplo, la imagen oficial de **MariaDb permite configurar** a través sus opciones: la contraseña del administrador, de la primera base de datos que se cree, sus usuarios, etc.
</script></section></section><section ><section data-markdown><script type="text/template">
# Dockerfile

- Un **Dockerfile** es un archivo de texto plano que contiene una serie de instrucciones necesarias para crear una imagen.
- Esta imagen luego se convertirá en los contenedores que ejecutamos en el sistema.
- El Dockerfile actúa como la **"receta" para definir la imagen**, que posteriormente lanzaremos como contenedor.
</script></section><section data-markdown><script type="text/template">
![2](https://github.com/maximofernandezriera/curso-docker/assets/43608040/675c4411-e628-4850-aa9c-2071482176e6)
</script></section></section><section ><section data-markdown><script type="text/template">
# En resumen
</script></section><section data-markdown><script type="text/template">
![Captura de pantalla de 2023-05-14 21-00-29](https://github.com/maximofernandezriera/curso-docker/assets/43608040/f7f281fb-3099-4a77-983b-bebc9dc5d930)
</script></section></section><section ><section data-markdown><script type="text/template">
# Instalar Docker

- Necesita un Linux.

-  Debido a que, dependiendo del sistema operativo y su versión, la forma de instalarlo difiere, es mejor consultar la **documentación oficial** para saber como instalar Docker en tu máquina: https://docs.docker.com/get-docker/

- Nosotros instalaremos la versión Community Edition (CE) que es de código abierto, de libre uso y distribución.
</script></section><section data-markdown><script type="text/template">
# Instalar Docker en Linux

- Pero hay algunas maneras de hacer el proceso más sencillo.

- Por ejemplo, en casi cualquier distribución de Linux, podemos lanzar el siguiente script **get-docker.sh** oficial de https://get.docker.com cuya documentación se encuentra en: https://github.com/docker/docker-install
</script></section><section data-markdown><script type="text/template">
# Sin usuario privilegiado

- Vamos a matizar algunas cosas: deberíamos instalar docker sin ser un usuario privilegiado, por ejemplo con:

        curl -fsSL https://get.docker.com/rootless | sh

- Y así nos ahorraríamos este paso: https://docs.docker.com/engine/security/rootless/
</script></section><section data-markdown><script type="text/template">
# Instalar Docker

- Efectivamente, en realidad, únicamente estamos instalando el demonio y el cliente de docker y necesataríamos algunas herramientas más que nos permiten, por ejemplo, utilizar Docker Compose.

- La instalación y su uso está pensado bajo línea de comandos pero que no cunda el pánico.
</script></section><section data-markdown><script type="text/template">
# Docker Desktop 

- Es un **entorno gráfico***, al que le podemos agregar extensiones, para trabajar con Docker.

- Esta pensado para trabajar el local, no está pensado para los entornos de producción.

- Desde que Docker Desktop está para todos los sistemas operativos, hace únicamente unos meses, se ha simplificado muchísimo la instlación. De todos modos, debemos tener en cuenta algunos puntos clave.
</script></section><section data-markdown><script type="text/template">
# Docker Desktop para Linux

- Debido a las numerosas distribuciones Docker Desktop funciona sobre una máquina virtual, lo que **penaliza** el consumo de recursos.

- La instalación es fácil y no tenemos que instalar el resto de componentes manualmente.

- [Aquí la documentación oficial.](https://docs.docker.com/desktop/install/linux-install)
</script></section><section data-markdown><script type="text/template">
# Docker Desktop para Windows

- El modo más utilizado necesita del Subsistema de Windows para Linux (WSL 2). Durante la instalación gráfica podemos elegirlo.
- Necesitamos tener activada la virtualización y alguna de las versiones o Home o Pro de Windows.
- [Aquí la documentación oficial.](https://docs.docker.com/desktop/install/windows-install/)
</script></section><section data-markdown><script type="text/template">
# Docker Desktop para Mac

- Disponemos de lo mejor de ambos mundos y la instalación es más sencilla que en Linux o Windows.
- Tened en cuenta los temas relacionados con el [chip](https://docs.docker.com/desktop/install/mac-install/)  los [permisos.](https://docs.docker.com/desktop/install/mac-install/)
- [Aquí la documentación oficial.](https://docs.docker.com/desktop/install/mac-install/)
</script></section></section><section ><section data-markdown><script type="text/template">
# Docker para VSCODE

[Market place de VS](https://marketplace.visualstudio.com/items?itemName=ms-azuretools.vscode-docker)
</script></section><section data-markdown><script type="text/template">
# Dockerhub

- **DockerHub** es el registro de imágenes donde podemos subir nuestras propias imágenes o encontrar imágenes preexistentes para trabajar con ellas.
- DockerHub puede ser usado de manera similar a GitHub, y podemos registrarnos en el servicio para almacenar nuestras imágenes.
</script></section><section data-markdown><script type="text/template">
![hub](https://github.com/maximofernandezriera/curso-docker/assets/43608040/9ae3e940-8618-4d86-846b-b80da6e488bb)
</script></section></section><section ><section data-markdown><script type="text/template">
# Hola mundo en Docker

        docker run hello-world

- Si conseguimos que ese mensaje se muestre significa que todo está correctamente instalado y que todo funciona como debería.
</script></section><section data-markdown><script type="text/template">
# Hola mundo en Docker

- Además de este hello-world hay alguno usuarios de la comunidad que han elaborado otras imágenes cuyo objetivo es el mismo, comprobar que todo está correcto, pero que muestran una apariencia más visualmente atractiva.
</script></section><section data-markdown><script type="text/template">
# Hola mundo en Docker

        docker run docker/whalesay cowsay Hola Toni Serna

        docker run -it --rm danielkraic/asciiquarium

¿Notáis alguna diferencia de comportamiento?

</script></section></section><section  data-markdown><script type="text/template">
### Comandos Docker

* La mejor manera de aprender los comandos es mediante su uso. Así que lo haremos de ese modo.
* En mi repositorio os he dejado las mejores **chuletas** que he encontrado.
Esta es de Red Hat: [Red Hat Developer](https://developers.redhat.com/download-manager/file/Docker_Cheat_Sheet)
* Vamos a pegarle un vistazo a los comandos y luego profundizaremos con el hello-world.
</script></section><section ><section data-markdown><script type="text/template">
# Sesión 2
</script></section><section data-markdown><script type="text/template">
# Una píldora 

* Una aplicación moderna está compuesta por un lenguaje de programación, una bases de datos y sus correspondientes liberías. 
* Docker permite a los desarrolladores empaquetar una aplicación y todos los componentes que necesita para funcionar en una caja estandarizada llamada contenedor.
</script></section><section data-markdown><script type="text/template">
# Repaso

* Para ello utilizamos comandos, como pudimos ver en la web de play with docker pero también tenemos una GUI disponible.

* Una Imagen es una plantilla que contiene las instrucciones para crear un contenedor Docker.
</script></section><section data-markdown><script type="text/template">
# Repaso

* Hoy trabajaremos más ejemplos para entender los comandos y comenzaremos a trabajar con los Dockerfiles.

* Son para definir la imagen, que posteriormente lanzaremos como contenedor
</script></section><section data-markdown><script type="text/template">
### Comandos Docker

* Para ver los comandos disponibles (en general y en particular):

        docker
        docker image
        docker network
</script></section><section data-markdown><script type="text/template">
* Para ver las opciones de cada comando:

        docker cp - -help
</script></section><section data-markdown><script type="text/template">
* Los comandos tienen a su vez opciones. Los nombres de las opciones van precedidas de los caracteres - - y entre la opción y su valor se puede escribir un espacio o el carácter =.

        docker COMANDO - -OPCIÓN=VALOR
        docker COMANDO - -OPCIÓN VALOR
</script></section><section data-markdown><script type="text/template">
* Si el valor de una opción contiene espacios, escriba el valor entre comillas

        docker COMANDO - -OPCIÓN "VALOR CON ESPACIOS"
</script></section><section data-markdown><script type="text/template">

### Comandos con imágenes

* Para gestionar las imágenes, se utiliza el comando:
        
        docker image OPCIONES
</script></section><section data-markdown><script type="text/template">
* Para descargar una imagen:

        docker image pull REPOSITORIO
        docker pull REPOSITORIO
</script></section><section data-markdown><script type="text/template">
* Para ver las imágenes ya descargadas:

        docker image ls
        docker images
</script></section><section data-markdown><script type="text/template">
* Para borrar una imagen (se deben borrar previamente los contenedores basados en esa imagen):

       docker image rm IMAGEN
       docker rmi IMAGEN
</script></section><section data-markdown><script type="text/template">
## Para, para. Mejor con un ejemplo
</script></section><section data-markdown><script type="text/template">
# Ejercicio 1.

* Comprueba que inicialmente no hay ningún contenedor creado (la opción - a hace que se muestren también los contenedores detenidos, sin ella se muestran sólo los contenedor que estén en marcha):
       
        docker ps - a
        docker container ls - a
</script></section><section data-markdown><script type="text/template">
* Comprueba que inicialmente tampoco disponemos de ninguna imagen:

        docker image ls
</script></section><section data-markdown><script type="text/template">
* Ahora podríamos utilizar la extensión de VSCODE o Docker Desktop para revisar todo.
</script></section><section data-markdown><script type="text/template">
* Docker crea los contenedores a partir de imágenes locales (ya descargadas), pero si al crear el contenedor **no se dispone** de la imagen local, Docker descarga la imagen de su repositorio.
</script></section><section data-markdown><script type="text/template">
* La orden más simple para crear un contenedor es:

       docker run IMAGEN
</script></section><section data-markdown><script type="text/template">
* Crea un contenedor con la aplicación de ejemplo hello-world. La imagen de este contenedor se llama hello-world:

       docker run hello-world
</script></section><section data-markdown><script type="text/template">
Cada contenedor tiene un identificador (ID) y un nombre distinto. Docker "bautiza" los contenedores con un nombre peculiar, compuesto de un adjetivo y un sustantivo.
</script></section><section data-markdown><script type="text/template">
Podemos crear tantos contenedores como queramos a partir de una imagen. Una vez la imagen está disponible localmente, Docker no necesita descargarla y el proceso de creación del contenedor es inmediato (aunque en el caso de hello-world la descarga es rápida, con imágenes más grandes la descarga inicial puede tardar un rato)
</script></section><section data-markdown><script type="text/template">
Normalmente se aconseja usar siempre la opción -d, que arranca el contenedor en segundo plano (detached) y permite seguir teniendo acceso a la shell (aunque con hello-world no es estrictamente necesario porque el contenedor hello-world se detiene automáticamente tras mostrar el mensaje).
</script></section><section data-markdown><script type="text/template">
Al crear el contenedor hello-world con la opción -d no se muestra el mensaje, simplemente muestra el identificador completo del contenedor.

</script></section><section data-markdown><script type="text/template">
Los contenedores se pueden destruir mediante el comando rm, haciendo referencia a ellos mediante su nombre o su id. No es necesario indicar el id completo, basta con escribir los primeros caracteres (de manera que no haya ambigüedades).
</script></section><section data-markdown><script type="text/template">
Borra los dos contenedores existentes:

       docker rm 1ae (o el nomnbre que le haya dado Docker)
       docker rm affectionate_varahamihira (o el nomnbre que le haya dado Docker)
</script></section><section data-markdown><script type="text/template">
Comprueba que ya no quedan contenedores.
</script></section><section data-markdown><script type="text/template">
### Comandos con contenedores

* Para crear un contenedor (y ponerlo en marcha):

       docker run - -name=CONTENEDOR REPOSITORIO

El problema de este comando es que dejamos de tener acceso a la shell y sólo se puede parar el proceso desde otro terminal.
</script></section><section data-markdown><script type="text/template">
Lo primero que hace es bajarse la imagen si no está en el sistema Lo habitual es poner en  archa el contenedor en modo separado o segundo plano (detached), es decir, en segundo plano, y así podemos seguir utilizando la shell:

       docker run - d - -name=CONTENEDOR REPOSITORIO
</script></section><section data-markdown><script type="text/template">
* Si queremos ver la secuencia de arranque del contenedor, podemos poner en marcha el  contenedor en modo pseudo-tty, que trabaja en primer plano, pero del que podemos salir con Ctrl+C.
      
        docker run - t - -name=CONTENEDOR REPOSITORIO
</script></section><section data-markdown><script type="text/template">
* Y ahora interacturaremos con el stdin.

        docker run - it - -name=CONTENEDOR REPOSITORIO
</script></section><section data-markdown><script type="text/template">
### Más comandos con contenedores

* Al crear el contenedor se pueden añadir diversas opciones:
</script></section><section data-markdown><script type="text/template">
* Para incluir el contenedor en una red privada virtual (y que se pueda comunicar con el resto de
contenedores incluidos en esa red):

       docker run - -name=CONTENEDOR - -net=RED REPOSITORIO
</script></section><section data-markdown><script type="text/template">
* Para que el contenedor atienda a un puerto determinado, aunque internamente atienda un puerto
distinto:


       docker run - -name=CONTENEDOR - p PUERTO_EXTERNO:PUERTO_INTERNO REPOSITORIO
</script></section><section data-markdown><script type="text/template">
* Para establecer variables de configuración del contenedor:

       docker run - -name=CONTENEDOR - e VARIABLE=VALOR REPOSITORIO

* Las variables de configuración se pueden consultar en el repositorio del que obtenemos la imagen.
</script></section><section data-markdown><script type="text/template">
### Comandos con contenedores

* Para ver los contenedores en funcionamiento:

       docker ps
</script></section><section data-markdown><script type="text/template">
* Para ver los contenedores en funcionamiento o detenidos:

       docker ps - a
</script></section><section data-markdown><script type="text/template">
* Para detener un contenedor:

       docker stop CONTENEDOR
</script></section><section data-markdown><script type="text/template">
* Para detener todos los contenedores:

       docker stop `($docker ps - aq)`
</script></section><section data-markdown><script type="text/template">
* Para borrar un contenedor:

       docker rm CONTENEDOR
</script></section><section data-markdown><script type="text/template">
* Para poner en marcha un contenedor detenido:

       docker start CONTENEDOR
</script></section><section data-markdown><script type="text/template">

### Comandos con contenedores

* Para entrar en la shell de un contenedor:

        docker exec - it CONTENEDOR /bin/bash
</script></section><section data-markdown><script type="text/template">
* Para entrar en la shell del contenedor como root:

        docker exec - u 0 - it CONTENEDOR /bin/bash
</script></section><section data-markdown><script type="text/template">
* Para salir de la shell del contenedor:

        exit
</script></section><section data-markdown><script type="text/template">
* Para copiar (o mover) archivos entre el contenedor y el sistema anfitrión o viceversa:

       docker cp CONTENEDOR:ORIGEN DESTINO
       docker cp ORIGEN CONTENEDOR:DESTINO
</script></section><section data-markdown><script type="text/template">
### Comandos de red

* Para gestionar las redes, se utiliza el comando:

       docker network OPCIONES
</script></section><section data-markdown><script type="text/template">
* Para crear una red:

       docker network create RED
</script></section><section data-markdown><script type="text/template">
* Para ver las redes existentes:

       docker network ls
</script></section><section data-markdown><script type="text/template">
* Para ver información detallada de una red (entre ella, los contenedores incluidos y sus IP privadas):

       docker network inspect RED
</script></section><section data-markdown><script type="text/template">
* Para borrar una red:

       docker network rm RED
</script></section><section data-markdown><script type="text/template">
### Comandos de sistema

* Para ver el espacio ocupado por las imágenes, los contenedores y los volúmenes:

       docker system df
</script></section><section data-markdown><script type="text/template">
* Esto también podemos hacerlo desde Docker Desktop.
</script></section><section data-markdown><script type="text/template">

* Para eliminar los elementos que no están en marcha:
</script></section><section data-markdown><script type="text/template">
Contenedores:

       docker container prune

Imágenes:

       docker image prune
</script></section><section data-markdown><script type="text/template">
Volúmenes:

       docker volume prune

Redes:

       docker network prune
</script></section><section data-markdown><script type="text/template">       
Todo:
       
       docker system prune - a
</script></section><section data-markdown><script type="text/template">
## Vamos con otro ejercicio para terminar de entenderlo
</script></section><section data-markdown><script type="text/template">
Una de las cosas en las que me atasqué un poco cuando empecé a trabajar con docker fue el hecho de que "a veces" me encontraba con que los contenedores se paraban y ya no podía acceder a ellos ni iniciarlos de nuevo (con docker start). Al principio no sabía el porqué y además me desconcertaba el hecho de que me pasaba con algunos contenedores y con otros no.
</script></section><section data-markdown><script type="text/template">
# Ejercicio 2

[Ejercicio 2](https://gist.github.com/maximofernandezriera/1fc42ec66de9221ae65dbf0a8e1657f7#file-ejercicio1-md)
</script></section><section data-markdown><script type="text/template">

# Ejercicio 2

* Ejecuta el contenedor en segundo plano:

        docker run -d --name my-web -p 8080:80 nginx

Pues poca cosa podemos hacer. No está mal pero no puedo interactuar, es decir, no lo puedo configurar.
</script></section><section data-markdown><script type="text/template">
# Ejercicio 2

* Ahora accede al shell del contenedor:

        docker exec -it my-web /bin/bash

Esto te permite acceder a un shell dentro del contenedor. Ahora estás dentro del contenedor y puedes ejecutar comandos en su entorno.
</script></section><section data-markdown><script type="text/template">
# Realiza modificaciones dentro del contenedor
</script></section><section data-markdown><script type="text/template">
- Con este comando, se cambia el contenido del archivo index.html dentro del contenedor.

       echo "Hola desde Marratxí" > /usr/share/nginx/html/index.html


</script></section><section data-markdown><script type="text/template">
# Salir del shell del contenedor:
</script></section><section data-markdown><script type="text/template">
Con el siguiente comando salimos del contenedor y vamos al host.

        exit
</script></section><section data-markdown><script type="text/template">
# El resultado

Abre tu navegador web y visita http://localhost:8080. Verás el contenido modificado del archivo index.html reflejado en la página web por defecto de nginx.
</script></section><section data-markdown><script type="text/template">
# Una pequeña broma con los contenedores y el exit
</script></section><section data-markdown><script type="text/template">
Podría salir de un terminal de plpgsql dentro del contenedor y seguidamente salir del contenedor.
</script></section><section data-markdown><script type="text/template">
[La peícula Origen](https://youtu.be/RV9L7ui9Cn8)
</script></section><section data-markdown><script type="text/template">
# En realidad va en contra de la filosofía de Docker, ya lo veremos
</script></section><section data-markdown><script type="text/template">
# Ejercicio 2, ¿lo hacemos juntos?

Crea un contenedor que contenga un servidor Apache a partir de la imagen apache
</script></section><section data-markdown><script type="text/template">
* La opción -P hace que Docker asigne de forma aleatoria un puerto de la máquina virtual al puerto asignado aApache en el contenedor. La imagen apache asigna a Apache el puerto 8080 del contenedor para conexiones http y el puerto 8443 para conexiones https.
</script></section><section data-markdown><script type="text/template">
# Parte 1. Vamos:


       docker run -d -P --name=apache-cursodevs apache

</script></section><section data-markdown><script type="text/template">
* Consulta el puerto del host utilizado por el contenedor

       docker ps -a

* Se mostrará el contenedor con el nombre que hemos indicado
</script></section><section data-markdown><script type="text/template">
* Abre en el navegador la página inicial del contenedor y compruebe que se muestra una página que dice "It works!".

* Aquí PWD te ayuda.
</script></section><section data-markdown><script type="text/template">
# Empieza lo bueno. Parte 2.

* Vamos a modificar la página web inicial de Apache del contenedor Docker.

</script></section><section data-markdown><script type="text/template">
* Debemos tener en cuenta que modificar el contenido de un contenedor tal y como vamos a hacer en este apartado sólo es aconsejable en un entorno de desarrollo, pero no es aconsejable en un entorno de producción porque va en contra de la "filosofía" de Docker.
</script></section><section data-markdown><script type="text/template">
* Los contenedores de Docker están pensados como objetos de "usar y tirar", es decir, para ser creados, destruidos y creados de nuevo tantas veces como sea necesario y en la cantidad que sea necesaria.
</script></section><section data-markdown><script type="text/template">
* Muy pronto realizaremos la misma tarea de una forma más conveniente, modificando no el
contenedor sino la imagen a partir de la cual se crean los contenedores.
</script></section><section data-markdown><script type="text/template">
* Los contenedores de Docker están pensados como objetos de "usar y tirar", es decir, para ser creados, destruidos y creados de nuevo tantas veces como sea necesario y en la cantidad que sea necesaria.

</script></section><section data-markdown><script type="text/template">
* Realizaremos la misma tarea de una forma más conveniente, modificando no el contenedor sino la imagen a partir de la cual se crean los contenedores.

</script></section><section data-markdown><script type="text/template">
* Crea un contenedor que contenga un servidor Apache a partir de la imagenhttpd

       docker run -d -P --name=apache-cursodevs httpd
</script></section><section data-markdown><script type="text/template">
* Consulta el puerto del host utilizado por el contenedor

       docker ps -a

* Se mostrarán los dos contenedores creados
</script></section><section data-markdown><script type="text/template">
* Crea la nueva página index.html ...

code index.html
</script></section><section data-markdown><script type="text/template">
* He creado una mediante chatgpt
</script></section><section data-markdown><script type="text/template">
OJO: https://gist.github.com/maximofernandezriera/389c48ce7b9949fe927b96bc1ac17a04
</script></section><section data-markdown><script type="text/template">
* Entra en la shell del contenedor para averiguar la ubicación de la página inicial:
       
       docker exec -it apache-cursodevs /bin/bash
</script></section><section data-markdown><script type="text/template">
* Sabemos que es: /usr/local/apache2/htdocs
</script></section><section data-markdown><script type="text/template">
* Salimos de la imagen

       exit
</script></section><section data-markdown><script type="text/template">
* Copiamos nuestra página web en esa ruta

       docker cp index.html apache-cursodevs:/usr/local/apache2/htdocs
</script></section><section data-markdown><script type="text/template">
* Ya tienes tu paǵina ejecutada con Docker

</script></section><section data-markdown><script type="text/template">
* Vamos a intentar ahorrarnos el copiar los ficheros siempre. Probamos lo siguiente desde donde tenemos la página web:

       docker run -dit --name apache-cursodevs -p 5555:80 -v "$PWD":/usr/local/apache2/htdocs httpd
</script></section><section data-markdown><script type="text/template">
* Una vez lanzado y puesto en marcha podemos ir a la dirección http://localhost:5555 con nuestro navegador y visitar nuestro sitio web funcionando desde el contenedor.
</script></section><section data-markdown><script type="text/template">
* Insisto, debemos tener en cuenta que modificar el contenido de un contenedor tal y como hemos hecho sólo es aconsejable en un entorno de desarrollo, pero no es aconsejable en un entorno de producción porque va en contra de la "filosofía" de Docker.
</script></section><section data-markdown><script type="text/template">
# Ejercicio 3. Hazlo mismo pero con otro servidor como nginx. Luego volvemos a él.
</script></section><section data-markdown><script type="text/template">
* Podríamos repetir el proceso, la única diferencia es que deberíamos tener cuidado con los directorios de uso y configuración de nginx.
</script></section><section data-markdown><script type="text/template">
# Y ahora, ¿cómo sería utilizando un Dockerfile?

       my-web-project/
       ├── Dockerfile
       └── index.html
</script></section><section data-markdown><script type="text/template">
       FROM nginx:latest

       COPY index.html /usr/share/nginx/html

       EXPOSE 80

       CMD ["nginx", "-g", "daemon off;"]
</script></section><section data-markdown><script type="text/template">
       docker run -it --name my-web-container -p 8080:80 my-web-image
</script></section><section data-markdown><script type="text/template">
# Dockerfile

* Un Dockerfile es un archivo de texto plano que contiene una serie de instrucciones necesarias para crear una imagen que, posteriormente, se convertirá en el **patrón** de nuestros **contenedores**. Para ello le añadimos:
</script></section><section data-markdown><script type="text/template">

* **FROM:** indica la imagen base sobre la que se construirá la aplicación dentro del contenedor.

       FROM <imagen>
       FROM <imagen>:<tag>

Por ejemplo la imagen puede ser un sistema operativo como Ubuntu, Centos, etc. O una imagen ya existente en la cual con base a esta queramos construir nuestra propia imagen.
</script></section><section data-markdown><script type="text/template">
* **RUN:** nos permite ejecutar comandos en el contenedor, por ejemplo, instalar paquetes o librerías (apt-get, yum install, etc.). Además, tenemos dos formas de colocarlo:
</script></section><section data-markdown><script type="text/template">
Opción 1 - > RUN <comando>
Esta instrucción ejecuta comandos Shell en el contenedor.
</script></section><section data-markdown><script type="text/template">
Opción 2 - > [“ejecutable”,” parametro 1 ”,” parametro 2 ”]
</script></section><section data-markdown><script type="text/template">
Esta otra instrucción bastante útil, que permite ejecutar comandos en imágenes que no tengan /bin/sh.
</script></section><section data-markdown><script type="text/template">
Generalmente se utiliza para ejecutar comandos o preparar distintos elementos que queremos que estén a la hora de tener nuestra imagen lista: librerías, dependencias, programas.
</script></section><section data-markdown><script type="text/template">
* **ENV:** establece variables de entorno para nuestro contenedor, en este caso la variable de entorno es DEBIAN_FRONTEND noninteractive, el cual nos permite instalar un montón de archivos .deb sin tener que interactuar con ellos.

       ENV <key><valor>
</script></section><section data-markdown><script type="text/template">
### Dockerfile

* **ADD:** esta instrucción copia archivos a un destino especifico dentro del contenedor, normalmente nos sirve para dejar ubicados ciertos archivos que queremos mover entre directorios, podemos usar como origen una URL o un .tar y descomprimirlo.

       ADD <fuente> <destino>
       ADD ./script.sh /var/tmp/script.sh
</script></section><section data-markdown><script type="text/template">
* **COPY:** esta instrucción copia archivos o directorios a un destino especifico dentro del contenedor.

       COPY <fuente> <destino>
       COPY ./run.sh /var/tmp/run.sh

* **LABEL** : Este nos permite, por ejemplo, indicar el nombre del autor del dockerfile.


       LABEL <nombre>
</script></section><section data-markdown><script type="text/template">
* **CMD** : esta instrucción nos provee valores por defecto a nuestro contenedor, es decir, mediante esta podemos definir una serie de comandos que solo se ejecutaran una vez que el contenedor se ha inicializado, pueden ser comandos Shell con parámetros establecidos.

       * CMD [“ejecutable”, “parámetro 1 ”, “parámetro 2 ”], este es el formato de ejecución.
       * CMD [“parámetro 1 ”, “parámetro 2 ”], parámetro por defecto para punto de entrada.
       * CMD comando parámetro 1 parámetro 2 , modo shell

</script></section><section data-markdown><script type="text/template">

### Dockerfile

* **ENTRYPOINT:** la instrucción entrypoint define el comando y los parámetros que se ejecutan primero cuando se ejecuta el contenedor. En simples palabras, todos los comandos pasados en la instrucción docker run <image> serán agregados al comando entrypoint.
</script></section><section data-markdown><script type="text/template">
* Opción 1 - > la forma exec es donde especificamos comandos y argumentos, como la sintaxis de los formatos JSON.
       ENTRYPOINT ["executable", "param 1 ", "param 2 "]
</script></section><section data-markdown><script type="text/template">
Opción 2 - > la otra forma es ejecutar un script para ejecutar los comandos que queremos como entrada en el contenedor.
       COPY ./script-entrypoint.sh /
       ENTRYPOINT ["/script-entrypoint.sh"]
       CMD ["postgres"]
</script></section><section data-markdown><script type="text/template">
* **VOLUME** : esta instrucción crea un volumen como punto de montaje dentro del contenedor y es visible desde el host anfitrión marcado con otro nombre.

       VOLUME /var/tmp
</script></section><section data-markdown><script type="text/template">
* **USER** : determina el nombre de usuario a utilizar cuando se ejecuta un contenedor, y adicionalmente cuando se ejecutan comandos como RUN, CMD, ENTRYPOINT o WORKDIR.

       WORKDIR ruta/de/Proyecto
</script></section><section data-markdown><script type="text/template">
# Ejercicio 4

Ahora vamos a revisar otro dockerfile, en el cual crearemos una imagen con base Ubuntu 22:04, por ejemplo y haremos las siguientes sub-tareas:
</script></section><section data-markdown><script type="text/template">
* Actualizar sus paquetes
* Instalar el paquete Nginx
* Añadir un archivo en una ruta especifica dentro del contenedor
* Exponer un puerto
</script></section><section data-markdown><script type="text/template">
# Descarga la imagen de Ubuntu 16.04

       FROM ubuntu:16.04
</script></section><section data-markdown><script type="text/template">
# Actualiza la imagen base de Ubuntu 16.04

       RUN apt-get update
</script></section><section data-markdown><script type="text/template">
# Ejecuta el commando apt-get install
</script></section><section data-markdown><script type="text/template">
# Elimina determinados archivos y temporales
</script></section><section data-markdown><script type="text/template">
       RUN apt-get install -y nginx \
       && rm -rf /var/lib/apt/lists/* /tmp/* /var/tmp/*
</script></section><section data-markdown><script type="text/template">
# Indica los puertos TCP/IP

       EXPOSE 80
</script></section><section data-markdown><script type="text/template">
# Establece el commando del proceso de inicio del contenedor

       CMD [“nginx”]
</script></section><section data-markdown><script type="text/template">
OJO: EXPOSE es una forma de documentar qué puertos deberían estar abiertos, mientras que -p o --publish realmente abre el puerto al sistema fuera del contenedor.
</script></section><section data-markdown><script type="text/template">
       docker build -t mi-ubuntu . (el punto es importante le dice donde esta el fichero Dockerfile, que es en este directorio)
</script></section><section data-markdown><script type="text/template">
       docker run -p 8080:80
</script></section><section data-markdown><script type="text/template">
# Ejercicio 5

Vamos a crear nuestra primera imagen de apache con php, para ello usaremos el fichero Dockerfile. Lo creamos teniendo
en cuenta: https://docs.docker.com/develop/develop-images/dockerfile_best-practices/
</script></section><section data-markdown><script type="text/template">
* El fichero Dockerfile define una una plantilla que le dice como serán nuestros contenedores
</script></section><section data-markdown><script type="text/template">
# Imagen a usar (es un poco antigua)

       FROM php:7.0-apache
</script></section><section data-markdown><script type="text/template">
# Copiamos todos los ficheros en el directorio en cuestion

       COPY src/ /var/www/html
</script></section><section data-markdown><script type="text/template">
# Exponemos el puerto 80

       EXPOSE 80
</script></section><section data-markdown><script type="text/template">
* Creamos la imagen con

       docker build -t miapache-php . (el punto es importante le dice donde esta el fichero Dockerfile, que es en este directorio)</script></section><section data-markdown><script type="text/template">
* Comprobamos que existe

       docker images
</script></section><section data-markdown><script type="text/template">
* Lanzamos la imagen

       docker run -dit --name miapache-php -p 5555:80 miapache-php
</script></section></section></div>
    </div>

    <script src="./dist/reveal.js"></script>

    <script src="./plugin/markdown/markdown.js"></script>
    <script src="./plugin/highlight/highlight.js"></script>
    <script src="./plugin/zoom/zoom.js"></script>
    <script src="./plugin/notes/notes.js"></script>
    <script src="./plugin/math/math.js"></script>
    <script>
      function extend() {
        var target = {};
        for (var i = 0; i < arguments.length; i++) {
          var source = arguments[i];
          for (var key in source) {
            if (source.hasOwnProperty(key)) {
              target[key] = source[key];
            }
          }
        }
        return target;
      }

      // default options to init reveal.js
      var defaultOptions = {
        controls: true,
        progress: true,
        history: true,
        center: true,
        transition: 'default', // none/fade/slide/convex/concave/zoom
        slideNumber: true,
        plugins: [
          RevealMarkdown,
          RevealHighlight,
          RevealZoom,
          RevealNotes,
          RevealMath
        ]
      };

      // options from URL query string
      var queryOptions = Reveal().getQueryHash() || {};

      var options = extend(defaultOptions, {}, queryOptions);
    </script>


    <script>
      Reveal.initialize(options);
    </script>
  </body>
</html>
